//This file is intended to gather data on the metrics developped.string DataOutputFileName = "PicNumTriangles.txt";cout<<"P1 Interpolation error for quadratic functions"<<endl;cout<<"comments written to"<<DataOutputFileName<<endl;ofstream DataOutput(DataOutputFileName);bool ShowMesh = true;bool ShowFunc = true;bool Show3D = false;bool ShowMeshAdapt = false;bool ComputeErrors = true;DataOutput << "errors : P1L2, P1H1, P2L2, P2H1" << endl;bool DoUnif = false;bool DoIsoP1 = false;//bool DoP1L2 = false;bool DoP1H1 = false;//bool DoP1H1Cond = false;//bool DoP2L2 = false;bool DoP2L2Cond = false;//bool DoP2H1 = false;//bool DoUnif = true;//bool DoIsoP1 = true;bool DoP1L2 = true;//bool DoP1H1 = true;bool DoP1H1Cond = true;bool DoP2L2 = true;//DoP2L2Cond = true;bool DoP2H1 = true;real H1Cond = 100;real P2L2Cond = 50;//pour stocker les erreurs d'approx.//attention : pas de += pour les stringstring AlgosTested = "";string NbTriangles = "";string StrCoef = "";string erP1L2 = "";string erP1H1 = "";string erP2L2 = "";string erP2H1 = "";load "Metriques/AllMetricsToFF"//the function of interest, and its derivatives.real c=10; //determines the width of the transition layerreal c2 = 10;DataOutput<< "Layer width : c = " << c << endl<< endl;func f = y^3/c2 + x^2*y  + tanh(c*(-2*x + sin(5*y)));func real sech(real X){return 2./(exp(X)+exp(-X));};func fxx = 2*(y - 4*c^2*sech(c*(-2*x + sin(5*y)))^2*tanh(c*(-2*x + sin(5*y))));func fxy = 2*(x + 10*c^2*cos(5*y)*sech(c*(-2*x + sin(5*y)))^2*tanh(c*(-2*x + sin(5*y))));func fyy = 6*y/c2 - 25*c*sech(c*(-2*x + sin(5*y)))^2*(sin(5*y) + 2*c*cos(5*y)^2*tanh(c*(-2*x + sin(5*y))));func normd2f = sqrt(fxx^2+2*fxy^2+fyy^2);func fxxx = -16*c^3*(-2 + cosh(2*c*(-2*x + sin(5*y))))*sech(c*(-2*x + sin(5*y)))^4;func fxxy = 2 - 40*c^3*cos(5*y)*sech(c*(-2*x + sin(5*y)))^4 + 80*c^3*cos(5*y)*sech(c*(-2*x + sin(5*y)))^2*tanh(c*(-2*x + sin(5*y)))^2;func fxyy = 100*c^2*sech(c*(-2*x + sin(5*y)))^2*(c*cos(5*y)^2*sech(c*(-2*x + sin(5*y)))^2 - tanh(c*(-2*x + sin(5*y)))*(sin(5*y) + 2*c*cos(5*y)^2*tanh(c*(-2*x + sin(5*y)))));func fyyy = 6/c2- 250*c^3*cos(5*y)^3*sech(c*(-2*x + sin(5*y)))^4 + 125*c*sech(c*(-2*x + sin(5*y)))^2*(-cos(5*y) + 3*c*sin(10*y)*tanh(c*(-2*x + sin(5*y))) + 4*c^2*cos(5*y)^3*tanh(c*(-2*x + sin(5*y)))^2);func normd3f = sqrt(fxxx^2+3*fxxy^2+3*fxyy^2+fyyy^2);real coef;int i;int firstIter=3;int CSplit = 3;mesh Th;mesh ThFine;/*//500 elementsint LargeurUnif=16;real CoefIsoP1 = 3.75;real CoefIsoP2 = 1.5;real CoefP1L2=6.89062;real CoefP1H1=0.17749;real CoefP1H1Cond = 0.546875;real CoefP2L2=2.9375;real CoefP2L2Cond = 2.875;real CoefP2H1=0.5;*//*//1000 elementsint LargeurUnif=22;real CoefIsoP1 = 8.9375;real CoefIsoP2 =  3.42188;real CoefP1L2= 21.5469;real CoefP1H1= 0.611201;real CoefP1H1Cond = 1.75098;real CoefP2L2= 9;real CoefP2L2Cond = 20.6169;real CoefP2H1= 1.67969;*///2000 elementsint LargeurUnif=32;real CoefIsoP1 = 19.4062;real CoefIsoP2 = 7.53516;real CoefP1L2= 51.8438;real CoefP1H1= 1.71875;real CoefP1H1Cond = 4.73438;real CoefP2L2= 21.875;real CoefP2L2Cond = 11.8672;real CoefP2H1= 4.35547;//**************************Uniform*******************************if(DoUnif){//d'abord les images pour Uniforme.//on veut 500 environ -> 250 sim 16^2mesh Th=square(LargeurUnif,LargeurUnif,[(x-0.5)*2,(y-0.5)*2]);fespace Vh(Th,P1);Vh fTest=f;DataOutput << "Uniform : " << Th.nt << " triangles." << endl;plot(Th, wait=ShowMesh, ps = "PicUnifMesh.eps");plot(fTest,wait = 1, ps="PicUniformF.eps");if(Show3D){   savemesh(Th,"mm",[x,y,fTest*.5]); //  save mm.points and mm.faces file for medit   // build a mm.bb file 	{ ofstream file("mm.bb"); 	file << "2 1 1 "<< fTest[].n << " 2 \n";	int j;	for (j=0;j<fTest[].n ; j++)  	  file << fTest[][j] << endl;     }      // call ffmedit command 	    exec("ffmedit mm");    // clean files    exec("rm mm.bb mm.faces mm.points");	};		if(ComputeErrors){	ThFine = trunc(Th,1,split=CSplit);		fespace Uh(Th,P1);	fespace UhFine(ThFine,P1);	fespace Wh(Th,P2);	fespace WhFine(ThFine,P2);		Uh 			fAdaptP1 	= f;	UhFine 	 fFineP1	 = f;	UhFine	 fTestP1	 = fAdaptP1;		Wh 			fAdaptP2 	= f;	WhFine 	 fFineP2	 = f;	WhFine	 fTestP2	 = fAdaptP2;				AlgosTested  = AlgosTested+ "Uniform, ";		StrCoef	= StrCoef+ " "+ string(coef)+" , ";		NbTriangles  = NbTriangles+ " "+string(Th.nt)+" ,  ";				erP1L2 = erP1L2+ " "+ string( int2d(ThFine)((fTestP1-fFineP1)^2) )+" ,  ";		erP1H1= erP1H1+ " "+ string( int2d(ThFine)((dx(fTestP1)-dx(fFineP1))^2+(dy(fTestP1)-dy(fFineP1))^2) ) + " ,  ";				erP2L2 = erP2L2+ " "+string( int2d(ThFine)((fTestP2-fFineP2)^2) )+ " , ";		erP2H1 = erP2H1+ " "+ string( int2d(ThFine)((dx(fTestP2)-dx(fFineP2))^2+(dy(fTestP2)-dy(fFineP2))^2) )+ " ,  ";	};	};//*************************** Iso P1 *********************************if(DoIsoP1){mesh Th=square(30,30,[(x-0.5)*2,(y-0.5)*2]);coef = CoefIsoP1;for(i=0;i<firstIter;i++){		Th = adaptmesh(Th,			coef*pow(normd2f,2/3.),			0,			coef*pow(normd2f,2/3.),		IsMetric=1);	if(ShowMeshAdapt){plot(Th,wait=1);};};fespace Vh(Th,P1);Vh fTest=f;DataOutput << "Iso PI : " << Th.nt << " triangles." << endl;plot(Th, wait=ShowMesh, ps = "PicIsoP1Mesh.eps");plot(fTest, wait=ShowFunc, ps = "PicIsoP1F.eps");if(Show3D){   savemesh(Th,"mm",[x,y,fTest*.5]); //  save mm.points and mm.faces file for medit   // build a mm.bb file 	{ ofstream file("mm.bb"); 	file << "2 1 1 "<< fTest[].n << " 2 \n";	int j;	for (j=0;j<fTest[].n ; j++)  	  file << fTest[][j] << endl;     }      // call ffmedit command 	    exec("ffmedit mm");    // clean files	exec("rm mm.bb mm.faces mm.points");	};		if(ComputeErrors){	ThFine = trunc(Th,1,split=CSplit);		fespace Uh(Th,P1);	fespace UhFine(ThFine,P1);	fespace Wh(Th,P2);	fespace WhFine(ThFine,P2);		Uh 			fAdaptP1 	= f;	UhFine 	 fFineP1	 = f;	UhFine	 fTestP1	 = fAdaptP1;		Wh 			fAdaptP2 	= f;	WhFine 	 fFineP2	 = f;	WhFine	 fTestP2	 = fAdaptP2;				AlgosTested  = AlgosTested+ " IsoP1, ";		StrCoef	= StrCoef+ " "+ string(coef)+" , ";		NbTriangles  = NbTriangles+ " "+string(Th.nt)+" ,  ";				erP1L2 = erP1L2+ " "+ string( int2d(ThFine)((fTestP1-fFineP1)^2) )+" ,  ";		erP1H1= erP1H1+ " "+ string( int2d(ThFine)((dx(fTestP1)-dx(fFineP1))^2+(dy(fTestP1)-dy(fFineP1))^2) ) + " ,  ";				erP2L2 = erP2L2+ " "+string( int2d(ThFine)((fTestP2-fFineP2)^2) )+ " , ";		erP2H1 = erP2H1+ " "+ string( int2d(ThFine)((dx(fTestP2)-dx(fFineP2))^2+(dy(fTestP2)-dy(fFineP2))^2) )+ " ,  ";	};	};//*****************************P1L2******************************if(DoP1L2){mesh Th=square(30,30,[(x-0.5)*2,(y-0.5)*2]);coef = CoefP1L2;for(i=0;i<firstIter;i++){	Th = adaptmesh(Th,		coef*MetricP1L2xx(fxx,fxy,fyy),		coef*MetricP1L2xy(fxx,fxy,fyy),		coef*MetricP1L2yy(fxx,fxy,fyy),		IsMetric=1);	if(ShowMeshAdapt){plot(Th,wait=1);};};fespace Vh(Th,P1);Vh fTest=f;DataOutput << "P1L2 : " << Th.nt << " triangles." << endl;plot(Th, wait=ShowMesh, ps = "PicP1L2Mesh.eps");plot(fTest, wait=ShowFunc, ps = "PicP1L2F.eps");if(Show3D){   savemesh(Th,"mm",[x,y,fTest*.5]); //  save mm.points and mm.faces file for medit   // build a mm.bb file 	{ ofstream file("mm.bb"); 	file << "2 1 1 "<< fTest[].n << " 2 \n";	int j;	for (j=0;j<fTest[].n ; j++)  	  file << fTest[][j] << endl;     }      // call ffmedit command 	    exec("ffmedit mm");    // clean files    exec("rm mm.bb mm.faces mm.points");};	if(ComputeErrors){	ThFine = trunc(Th,1,split=CSplit);		fespace Uh(Th,P1);	fespace UhFine(ThFine,P1);	fespace Wh(Th,P2);	fespace WhFine(ThFine,P2);		Uh 			fAdaptP1 	= f;	UhFine 	 fFineP1	 = f;	UhFine	 fTestP1	 = fAdaptP1;		Wh 			fAdaptP2 	= f;	WhFine 	 fFineP2	 = f;	WhFine	 fTestP2	 = fAdaptP2;				AlgosTested  = AlgosTested+ "P1L2, ";		StrCoef	= StrCoef+ " "+ string(coef)+" , ";		NbTriangles  = NbTriangles+ " "+string(Th.nt)+" ,  ";				erP1L2 = erP1L2+ " "+ string( int2d(ThFine)((fTestP1-fFineP1)^2) )+" ,  ";		erP1H1= erP1H1+ " "+ string( int2d(ThFine)((dx(fTestP1)-dx(fFineP1))^2+(dy(fTestP1)-dy(fFineP1))^2) ) + " ,  ";				erP2L2 = erP2L2+ " "+string( int2d(ThFine)((fTestP2-fFineP2)^2) )+ " , ";		erP2H1 = erP2H1+ " "+ string( int2d(ThFine)((dx(fTestP2)-dx(fFineP2))^2+(dy(fTestP2)-dy(fFineP2))^2) )+ " ,  ";	};};//*****************************P1H1******************************if(DoP1H1){mesh Th=square(30,30,[(x-0.5)*2,(y-0.5)*2]);coef = CoefP1H1;for(i=0;i<firstIter;i++){	Th = adaptmesh(Th,		coef*MetricP1H1xx(fxx,fxy,fyy),		coef*MetricP1H1xy(fxx,fxy,fyy),		coef*MetricP1H1yy(fxx,fxy,fyy),		IsMetric=1);	if(ShowMeshAdapt){plot(Th,wait=1);};};fespace Vh(Th,P1);Vh fTest=f;DataOutput << "P1H1 : " << Th.nt << " triangles." << endl;plot(Th, wait=ShowMesh, ps = "PicP1H1Mesh.eps");plot(fTest, wait=ShowFunc, ps = "PicP1H1F.eps");if(Show3D){   savemesh(Th,"mm",[x,y,fTest*.5]); //  save mm.points and mm.faces file for medit   // build a mm.bb file 	{ ofstream file("mm.bb"); 	file << "2 1 1 "<< fTest[].n << " 2 \n";	int j;	for (j=0;j<fTest[].n ; j++)  	  file << fTest[][j] << endl;     }      // call ffmedit command 	    exec("ffmedit mm");    // clean files    exec("rm mm.bb mm.faces mm.points");};		if(ComputeErrors){	ThFine = trunc(Th,1,split=CSplit);		fespace Uh(Th,P1);	fespace UhFine(ThFine,P1);	fespace Wh(Th,P2);	fespace WhFine(ThFine,P2);		Uh 			fAdaptP1 	= f;	UhFine 	 fFineP1	 = f;	UhFine	 fTestP1	 = fAdaptP1;		Wh 			fAdaptP2 	= f;	WhFine 	 fFineP2	 = f;	WhFine	 fTestP2	 = fAdaptP2;				AlgosTested  = AlgosTested+ "P1H1, ";		StrCoef	= StrCoef+ " "+ string(coef)+" , ";		NbTriangles  = NbTriangles+ " "+string(Th.nt)+" ,  ";				erP1L2 = erP1L2+ " "+ string( int2d(ThFine)((fTestP1-fFineP1)^2) )+" ,  ";		erP1H1= erP1H1+ " "+ string( int2d(ThFine)((dx(fTestP1)-dx(fFineP1))^2+(dy(fTestP1)-dy(fFineP1))^2) ) + " ,  ";				erP2L2 = erP2L2+ " "+string( int2d(ThFine)((fTestP2-fFineP2)^2) )+ " , ";		erP2H1 = erP2H1+ " "+ string( int2d(ThFine)((dx(fTestP2)-dx(fFineP2))^2+(dy(fTestP2)-dy(fFineP2))^2) )+ " ,  ";	};};//*****************************P1H1Cond******************************if(DoP1H1Cond){mesh Th=square(30,30,[(x-0.5)*2,(y-0.5)*2]);coef = CoefP1H1Cond;for(i=0;i<firstIter;i++){	Th = adaptmesh(Th,		coef*MetricP1H1Condxx(fxx,fxy,fyy, H1Cond),		coef*MetricP1H1Condxy(fxx,fxy,fyy, H1Cond),		coef*MetricP1H1Condyy(fxx,fxy,fyy, H1Cond),		IsMetric=1);	if(ShowMeshAdapt){plot(Th,wait=1);};};		fespace Vh(Th,P1);Vh fTest=f;DataOutput << "P1H1Cond : " << Th.nt << " triangles." << endl;plot(Th, wait=ShowMesh, ps = "PicP1H1CondMesh.eps");plot(fTest, wait=ShowFunc, ps = "PicP1H1CondF.eps");if(Show3D){   savemesh(Th,"mm",[x,y,fTest*.5]); //  save mm.points and mm.faces file for medit   // build a mm.bb file 	{ ofstream file("mm.bb"); 	file << "2 1 1 "<< fTest[].n << " 2 \n";	int j;	for (j=0;j<fTest[].n ; j++)  	  file << fTest[][j] << endl;     }      // call ffmedit command 	    exec("ffmedit mm");    // clean files    exec("rm mm.bb mm.faces mm.points");};		if(ComputeErrors){	ThFine = trunc(Th,1,split=CSplit);		fespace Uh(Th,P1);	fespace UhFine(ThFine,P1);	fespace Wh(Th,P2);	fespace WhFine(ThFine,P2);		Uh 			fAdaptP1 	= f;	UhFine 	 fFineP1	 = f;	UhFine	 fTestP1	 = fAdaptP1;		Wh 			fAdaptP2 	= f;	WhFine 	 fFineP2	 = f;	WhFine	 fTestP2	 = fAdaptP2;				AlgosTested  = AlgosTested+ "P1H1Cond(H1Cond = "+ string(H1Cond)+") ,  ";		StrCoef	= StrCoef+ " "+ string(coef)+" , ";		NbTriangles  = NbTriangles+ " "+string(Th.nt)+" ,  ";				erP1L2 = erP1L2+ " "+ string( int2d(ThFine)((fTestP1-fFineP1)^2) )+" ,  ";		erP1H1= erP1H1+ " "+ string( int2d(ThFine)((dx(fTestP1)-dx(fFineP1))^2+(dy(fTestP1)-dy(fFineP1))^2) ) + " ,  ";				erP2L2 = erP2L2+ " "+string( int2d(ThFine)((fTestP2-fFineP2)^2) )+ " , ";		erP2H1 = erP2H1+ " "+ string( int2d(ThFine)((dx(fTestP2)-dx(fFineP2))^2+(dy(fTestP2)-dy(fFineP2))^2) )+ " ,  ";	};};//****************************P2L2*******************************if(DoP2L2){mesh Th=square(30,30,[(x-0.5)*2,(y-0.5)*2]);coef = CoefP2L2;for(i=0;i<firstIter;i++){	Th = adaptmesh(Th,		coef*MetricP2L2xx(fxxx,fxxy,fxyy,fyyy),		coef*MetricP2L2xy(fxxx,fxxy,fxyy,fyyy),		coef*MetricP2L2yy(fxxx,fxxy,fxyy,fyyy),		IsMetric=1);	if(ShowMeshAdapt){plot(Th,wait=1);};};fespace Vh(Th,P2);Vh fTest=f;DataOutput << "P2L2 : " << Th.nt << " triangles." << endl;plot(Th, wait=ShowMesh, ps = "PicP2L2Mesh.eps");plot(fTest, wait=ShowFunc, ps = "PicP2L2F.eps");		/*mesh ThFine = trunc(Th,1,split = 5);fespace Wh(ThFine,P1);Wh fP2P1 = fTest;if(Show3D){   savemesh(Th,"mm",[x,y,fTest*.5]); //  save mm.points and mm.faces file for medit   // build a mm.bb file 	{ ofstream file("mm.bb"); 	file << "2 1 1 "<< fTest[].n << " 2 \n";	int j;	for (j=0;j<fTest[].n ; j++)  	  file << fTest[][j] << endl;     }      // call ffmedit command 	    exec("ffmedit mm");    // clean files    exec("rm mm.bb mm.faces mm.points");};	*/	if(ComputeErrors){	ThFine = trunc(Th,1,split=CSplit);		fespace Uh(Th,P1);	fespace UhFine(ThFine,P1);	fespace Wh(Th,P2);	fespace WhFine(ThFine,P2);		Uh 			fAdaptP1 	= f;	UhFine 	 fFineP1	 = f;	UhFine	 fTestP1	 = fAdaptP1;		Wh 			fAdaptP2 	= f;	WhFine 	 fFineP2	 = f;	WhFine	 fTestP2	 = fAdaptP2;				AlgosTested  = AlgosTested+ "P2L2, ";		StrCoef	= StrCoef+ " "+ string(coef)+" , ";		NbTriangles  = NbTriangles+ " "+string(Th.nt)+" ,  ";				erP1L2 = erP1L2+ " "+ string( int2d(ThFine)((fTestP1-fFineP1)^2) )+" ,  ";		erP1H1= erP1H1+ " "+ string( int2d(ThFine)((dx(fTestP1)-dx(fFineP1))^2+(dy(fTestP1)-dy(fFineP1))^2) ) + " ,  ";				erP2L2 = erP2L2+ " "+string( int2d(ThFine)((fTestP2-fFineP2)^2) )+ " , ";		erP2H1 = erP2H1+ " "+ string( int2d(ThFine)((dx(fTestP2)-dx(fFineP2))^2+(dy(fTestP2)-dy(fFineP2))^2) )+ " ,  ";	};};//****************************P2L2 Cond*******************************if(DoP2L2Cond){mesh Th=square(30,30,[(x-0.5)*2,(y-0.5)*2]);coef = CoefP2L2Cond;for(i=0;i<firstIter;i++){	Th = adaptmesh(Th,		coef*MetricP2L2Condxx(fxxx,fxxy,fxyy,fyyy,P2L2Cond),		coef*MetricP2L2Condxy(fxxx,fxxy,fxyy,fyyy,P2L2Cond),		coef*MetricP2L2Condyy(fxxx,fxxy,fxyy,fyyy,P2L2Cond),		IsMetric=1);	if(ShowMeshAdapt){plot(Th,wait=1);};};fespace Vh(Th,P2);Vh fTest=f;DataOutput << "P2L2 Cond: " << Th.nt << " triangles." << endl;plot(Th, wait=ShowMesh, ps = "PicP2L2CondMesh.eps");plot(fTest, wait=ShowFunc, ps = "PicP2L2CondF.eps");		/*mesh ThFine = trunc(Th,1,split = 5);fespace Wh(ThFine,P1);Wh fP2P1 = fTest;if(Show3D){   savemesh(Th,"mm",[x,y,fTest*.5]); //  save mm.points and mm.faces file for medit   // build a mm.bb file 	{ ofstream file("mm.bb"); 	file << "2 1 1 "<< fTest[].n << " 2 \n";	int j;	for (j=0;j<fTest[].n ; j++)  	  file << fTest[][j] << endl;     }      // call ffmedit command 	    exec("ffmedit mm");    // clean files    exec("rm mm.bb mm.faces mm.points");};	*/	if(ComputeErrors){	ThFine = trunc(Th,1,split=CSplit);		fespace Uh(Th,P1);	fespace UhFine(ThFine,P1);	fespace Wh(Th,P2);	fespace WhFine(ThFine,P2);		Uh 			fAdaptP1 	= f;	UhFine 	 fFineP1	 = f;	UhFine	 fTestP1	 = fAdaptP1;		Wh 			fAdaptP2 	= f;	WhFine 	 fFineP2	 = f;	WhFine	 fTestP2	 = fAdaptP2;				AlgosTested  = AlgosTested+ "P2L2Cond (P2L2Cond = "+string(P2L2Cond)+"),  ";		StrCoef	= StrCoef+ " "+ string(coef)+" , ";		NbTriangles  = NbTriangles+ " "+string(Th.nt)+" ,  ";				erP1L2 = erP1L2+ " "+ string( int2d(ThFine)((fTestP1-fFineP1)^2) )+" ,  ";		erP1H1= erP1H1+ " "+ string( int2d(ThFine)((dx(fTestP1)-dx(fFineP1))^2+(dy(fTestP1)-dy(fFineP1))^2) ) + " ,  ";				erP2L2 = erP2L2+ " "+string( int2d(ThFine)((fTestP2-fFineP2)^2) )+ " , ";		erP2H1 = erP2H1+ " "+ string( int2d(ThFine)((dx(fTestP2)-dx(fFineP2))^2+(dy(fTestP2)-dy(fFineP2))^2) )+ " ,  ";	};};//********************************P2H1*******************************if(DoP2H1){mesh Th=square(30,30,[(x-0.5)*2,(y-0.5)*2]);coef = CoefP2H1;for(i=0;i<firstIter;i++){	Th = adaptmesh(Th,		coef*MetricP2H1xx(fxxx,fxxy,fxyy,fyyy),		coef*MetricP2H1xy(fxxx,fxxy,fxyy,fyyy),		coef*MetricP2H1yy(fxxx,fxxy,fxyy,fyyy),		IsMetric=1);	if(ShowMeshAdapt){plot(Th,wait=1);};};fespace Vh(Th,P2);Vh fTest=f;DataOutput << "P2H1 : " << Th.nt << " triangles." << endl;plot(Th, wait=ShowMesh, ps = "PicP2H1Mesh.eps");plot(fTest, wait=ShowFunc, ps = "PicP2H1F.eps");/*mesh ThFine = trunc(Th,1,split = 5);fespace Wh(ThFine,P1);Wh fP2P1 = fTest;if(Show3D){   savemesh(ThFine,"mm",[x,y,fP2P1*.5]); //  save mm.points and mm.faces file for medit   // build a mm.bb file 	{ ofstream file("mm.bb"); 	file << "2 1 1 "<< fP2P1[].n << " 2 \n";	int j;	for (j=0;j<fP2P1[].n ; j++)  	  file << fP2P1[][j] << endl;     }      // call ffmedit command 	    exec("ffmedit mm");    // clean files    exec("rm mm.bb mm.faces mm.points");};*/	if(ComputeErrors){	ThFine = trunc(Th,1,split=CSplit);		fespace Uh(Th,P1);	fespace UhFine(ThFine,P1);	fespace Wh(Th,P2);	fespace WhFine(ThFine,P2);		Uh 			fAdaptP1 	= f;	UhFine 	 fFineP1	 = f;	UhFine	 fTestP1	 = fAdaptP1;		Wh 			fAdaptP2 	= f;	WhFine 	 fFineP2	 = f;	WhFine	 fTestP2	 = fAdaptP2;				AlgosTested  = AlgosTested+ "P2H1, ";		StrCoef	= StrCoef+ " "+ string(coef)+" , ";		NbTriangles  = NbTriangles+ " "+string(Th.nt)+" ,  ";				erP1L2 = erP1L2+ " "+ string( int2d(ThFine)((fTestP1-fFineP1)^2) )+" ,  ";		erP1H1= erP1H1+ " "+ string( int2d(ThFine)((dx(fTestP1)-dx(fFineP1))^2+(dy(fTestP1)-dy(fFineP1))^2) ) + " ,  ";				erP2L2 = erP2L2+ " "+string( int2d(ThFine)((fTestP2-fFineP2)^2) )+ " , ";		erP2H1 = erP2H1+ " "+ string( int2d(ThFine)((dx(fTestP2)-dx(fFineP2))^2+(dy(fTestP2)-dy(fFineP2))^2) )+ " ,  ";	};	};//Žcriture des erreurs dans le fichier.DataOutput << "AlgosTested = { " << AlgosTested <<  " };" << endl;DataOutput << "NbTriangles = {" << NbTriangles << "};"<< endl;DataOutput << "coef = {" << StrCoef << "};"<< endl;DataOutput << "erP1L2 = {" << erP1L2 << "};"<< endl;DataOutput << "erP1H1 = {" << erP1H1 << "};"<< endl;DataOutput << "erP2L2 = {" << erP2L2 << "};"<< endl;DataOutput << "erP2H1 = {" << erP2H1 << "};"<< endl;end;		