/*Example file on how to use the optimised metrics.*//*load the library of metric definitions*/		load "Metriques/AllMetricsToFF"		/*favorite test function*/real c=10;func f = x^2*y + y^3 + tanh(c*(-2*x + sin(5*y)));func real sech(real X){return 2./(exp(X)+exp(-X));};func fxx = 2*(y - 4*c^2*sech(c*(-2*x + sin(5*y)))^2*tanh(c*(-2*x + sin(5*y))));func fxy = 2*(x + 10*c^2*cos(5*y)*sech(c*(-2*x + sin(5*y)))^2*tanh(c*(-2*x + sin(5*y))));func fyy = 6*y - 25*c*sech(c*(-2*x + sin(5*y)))^2*(sin(5*y) + 2*c*cos(5*y)^2*tanh(c*(-2*x + sin(5*y))));func normd2f = sqrt(fxx^2+2*fxy^2+fyy^2);func fxxx = -16*c^3*(-2 + cosh(2*c*(-2*x + sin(5*y))))*sech(c*(-2*x + sin(5*y)))^4;func fxxy = 2 - 40*c^3*cos(5*y)*sech(c*(-2*x + sin(5*y)))^4 + 80*c^3*cos(5*y)*sech(c*(-2*x + sin(5*y)))^2*tanh(c*(-2*x + sin(5*y)))^2;func fxyy = 100*c^2*sech(c*(-2*x + sin(5*y)))^2*(c*cos(5*y)^2*sech(c*(-2*x + sin(5*y)))^2 - tanh(c*(-2*x + sin(5*y)))*(sin(5*y) + 2*c*cos(5*y)^2*tanh(c*(-2*x + sin(5*y)))));func fyyy = 6 - 250*c^3*cos(5*y)^3*sech(c*(-2*x + sin(5*y)))^4 + 125*c*sech(c*(-2*x + sin(5*y)))^2*(-cos(5*y) + 3*c*sin(10*y)*tanh(c*(-2*x + sin(5*y))) + 4*c^2*cos(5*y)^3*tanh(c*(-2*x + sin(5*y)))^2);func normd3f = sqrt(fxxx^2+3*fxxy^2+3*fxyy^2+fyyy^2);real coef500; real coef1000; real coef2000;/********************** Choice of the metric ********************///Uncomment precisely one of these blocks, in order to choose the metric./*//IsoP1DataOutput << "IsoP1" << endl;func metricxx = pow(normd2f,2/3.);func metricxy = 0;func metricyy = pow(normd2f,2/3.);coef500 = 3.75; coef1000 = 8.9375; coef2000 = 19.4062;*//*//IsoP2DataOutput << "IsoP2" << endl;func metricxx = pow(normd3f,1/2.);func metricxy = 0;func metricyy = pow(normd3f,1/2.);coef500 = 1.5; coef1000 = 3.42188; coef2000 = 7.53516;*//*//P1L2DataOutput << "P1L2" << endl;func metricxx = MetricP1L2xx(fxx,fxy,fyy);func metricxy = MetricP1L2xy(fxx,fxy,fyy);func metricyy = MetricP1L2yy(fxx,fxy,fyy);coef500 = 6.89062; coef1000 = 20.0312; coef2000 = 50.2188;*//*//P1H1DataOutput << "P1H1" << endl;func metricxx =	MetricP1H1xx(fxx,fxy,fyy);func metricxy =	MetricP1H1xy(fxx,fxy,fyy);func metricyy =	MetricP1H1yy(fxx,fxy,fyy);coef500 = 0.17749; coef1000 = 0.610352; coef2000 = 1.90625;*//*//P1H1Condreal H1Cond = 100;DataOutput << "P1H1Cond, H1Cond = " << H1Cond << endl;func metricxx =	MetricP1H1Condxx(fxx,fxy,fyy,H1Cond);func metricxy =	MetricP1H1Condxy(fxx,fxy,fyy,H1Cond);func metricyy =	MetricP1H1Condyy(fxx,fxy,fyy,H1Cond);coef500 = 0.546875; coef1000 = 1.75098; coef2000 = 4.61719;*//*//P2L2DataOutput << "P2L2" << endl;func metricxx =	MetricP2L2xx(fxxx,fxxy,fxyy,fyyy);func metricxy =	MetricP2L2xy(fxxx,fxxy,fxyy,fyyy);func metricyy =	MetricP2L2yy(fxxx,fxxy,fxyy,fyyy);coef500 = 2.9375; coef1000 = 9; coef2000 = 21.875;*//*//P2L2Condreal P2L2Cond = 10;DataOutput << "P2L2Cond, P2L2Cond = " << P2L2Cond << endl;func metricxx =	MetricP2L2Condxx(fxxx,fxxy,fxyy,fyyy,P2L2Cond);func metricxy =	MetricP2L2Condxy(fxxx,fxxy,fxyy,fyyy,P2L2Cond);func metricyy =	MetricP2L2Condyy(fxxx,fxxy,fxyy,fyyy,P2L2Cond);coef500 = 2.875; coef1000 = 7.07812; coef2000 = 16;*///P2H1DataOutput << "P2H1" << endl;func metricxx =	MetricP2H1xx(fxxx,fxxy,fxyy,fyyy);func metricxy =	MetricP2H1xy(fxxx,fxxy,fxyy,fyyy);func metricyy =	MetricP2H1yy(fxxx,fxxy,fxyy,fyyy);coef500 = 0.5; coef1000 = 1.67969; coef2000 = 4.40234;/*************************** Mesh adaptation loop *****************************/int nbIter = 3; //number of iterations in the adaptation loop//choose if you want 500, 1000 or 2000 triangles in the adapted mesh.real coef = coef500;//real coef = coef1000;//real coef = coef2000;mesh Th=square(22, 22, [(x-0.5)*2,(y-0.5)*2]);;for(int i=0; i<nbIter; i++){		Th = adaptmesh(Th,				coef*metricxx,				coef*metricxy,				coef*metricyy,				IsMetric = 1);};/******** Plotting the mesh, the P1 interpolant, the P2 interpolant ********/fespace Vh(Th,P1);fespace Vh2(Th,P2);Vh  fP1 = f;Vh2 fP2 = f;plot(Th,  wait = 1, cmm = "nb of elements : " + Th.nt);plot(fP1, wait = 1, cmm = "P1 interpolant");plot(fP2, wait = 1, cmm = "P2 interpolant");