load "Metriques/Metriques"//------------définition de la fonction test----------real c=10; //determines the width of the transition layerfunc f = x^2*y + y^3 + tanh(c*(-2*x + sin(5*y)));func real sech(real X){return 2./(exp(X)+exp(-X));};func fxx = 2*(y - 4*c^2*sech(c*(-2*x + sin(5*y)))^2*tanh(c*(-2*x + sin(5*y))));func fxy = 2*(x + 10*c^2*cos(5*y)*sech(c*(-2*x + sin(5*y)))^2*tanh(c*(-2*x + sin(5*y))));func fyy = 6*y - 25*c*sech(c*(-2*x + sin(5*y)))^2*(sin(5*y) + 2*c*cos(5*y)^2*tanh(c*(-2*x + sin(5*y))));func fxxx = -16*c^3*(-2 + cosh(2*c*(-2*x + sin(5*y))))*sech(c*(-2*x + sin(5*y)))^4;func fxxy = 2 - 40*c^3*cos(5*y)*sech(c*(-2*x + sin(5*y)))^4 + 80*c^3*cos(5*y)*sech(c*(-2*x + sin(5*y)))^2*tanh(c*(-2*x + sin(5*y)))^2;func fxyy = 100*c^2*sech(c*(-2*x + sin(5*y)))^2*(c*cos(5*y)^2*sech(c*(-2*x + sin(5*y)))^2 - tanh(c*(-2*x + sin(5*y)))*(sin(5*y) + 2*c*cos(5*y)^2*tanh(c*(-2*x + sin(5*y)))));func fyyy = 6 - 250*c^3*cos(5*y)^3*sech(c*(-2*x + sin(5*y)))^4 + 125*c*sech(c*(-2*x + sin(5*y)))^2*(-cos(5*y) + 3*c*sin(10*y)*tanh(c*(-2*x + sin(5*y))) + 4*c^2*cos(5*y)^3*tanh(c*(-2*x + sin(5*y)))^2);//------------création des triangulations-----------mesh ThRef=square(30,30,[(x-0.5)*2,(y-0.5)*2]); mesh Th;real coef=1.;real maxRatio = 10; //il est possible, en option, de borner le rapport d'aspect des triangles.int nbIter = 3;{	coef = 0.640625; //prévu pour 500 triangles	func metricxx =	MetricP1xx(fxx,fxy,fyy);	func metricxy =	MetricP1xy(fxx,fxy,fyy);	func metricyy =	MetricP1yy(fxx,fxy,fyy);		Th=ThRef; 	for(int i=0;i < nbIter;i++){		Th = adaptmesh(Th,				coef*metricxx,				coef*metricxy,				coef*metricyy,				IsMetric=1);		};	plot(Th, wait=true);	};{	coef = 0.75; //prévu pour 500 triangles	func metricxx =	MetricP1Condxx(fxx,fxy,fyy,maxRatio);	func metricxy =	MetricP1Condxy(fxx,fxy,fyy,maxRatio);	func metricyy =	MetricP1Condyy(fxx,fxy,fyy,maxRatio);		Th=ThRef; 	for(int i=0;i < nbIter;i++){		Th = adaptmesh(Th,				coef*metricxx,				coef*metricxy,				coef*metricyy,				IsMetric=1);		};	plot(Th, wait=true);	};{	coef = 0.597656; //prévu pour 500 triangles	func metricxx =	MetricP2xx(fxxx,fxxy,fxyy,fyyy);	func metricxy =	MetricP2xy(fxxx,fxxy,fxyy,fyyy);	func metricyy =	MetricP2yy(fxxx,fxxy,fxyy,fyyy);		Th=ThRef; 	for(int i=0;i < nbIter;i++){		Th = adaptmesh(Th,				coef*metricxx,				coef*metricxy,				coef*metricyy,				IsMetric=1);		};	plot(Th, wait=true);	};{	coef = 0.601562; //prévu pour 500 triangles	func metricxx =	MetricP2Condxx(fxxx,fxxy,fxyy,fyyy,maxRatio);	func metricxy =	MetricP2Condxy(fxxx,fxxy,fxyy,fyyy,maxRatio);	func metricyy =	MetricP2Condyy(fxxx,fxxy,fxyy,fyyy,maxRatio);		Th=ThRef; 	for(int i=0;i < nbIter;i++){		Th = adaptmesh(Th,				coef*metricxx,				coef*metricxy,				coef*metricyy,				IsMetric=1);		};	plot(Th, wait=true);	};